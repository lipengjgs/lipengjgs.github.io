import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as n,e as l}from"./app-D1HYAr-Z.js";const t={},o=l('<h2 id="一、开闭原则-open-close-principle" tabindex="-1"><a class="header-anchor" href="#一、开闭原则-open-close-principle"><span>一、开闭原则（Open Close Principle）</span></a></h2><blockquote><p>软件实体应当对扩展开放，对修改关闭</p></blockquote><blockquote><p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p></blockquote><ol><li>项目中划分出的模块；</li><li>类与接口</li><li>方法</li></ol><p>&quot;抽象约束、封装变化&quot;：即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><h2 id="二、里氏替换原则-liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#二、里氏替换原则-liskov-substitution-principle"><span>二、里氏替换原则（Liskov Substitution Principle）</span></a></h2><blockquote><p>子类可以扩展父类的功能，但不能改变父类原有的功能</p></blockquote><blockquote><p>修正方法：程序违背了里氏替换原则，取消原来的继承关系，重新设计它们之间的关系 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></blockquote><h2 id="三、依赖倒置原则-dependence-inversion-principle" tabindex="-1"><a class="header-anchor" href="#三、依赖倒置原则-dependence-inversion-principle"><span>三、依赖倒置原则（Dependence Inversion Principle）</span></a></h2><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节，细节应该依赖抽象 面向接口编程！！</p><ol><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ol><h2 id="四、单一职责原则" tabindex="-1"><a class="header-anchor" href="#四、单一职责原则"><span>四、单一职责原则</span></a></h2><blockquote><p>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</p></blockquote><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h2 id="五、接口隔离原则-interface-segregation-principle" tabindex="-1"><a class="header-anchor" href="#五、接口隔离原则-interface-segregation-principle"><span>五、接口隔离原则（Interface Segregation Principle）</span></a></h2><blockquote><p>尽量将臃肿庞大的接口拆分成更小的和更具体的接口</p></blockquote><h2 id="六、迪米特法则" tabindex="-1"><a class="header-anchor" href="#六、迪米特法则"><span>六、迪米特法则</span></a></h2><blockquote><p>只与你的直接朋友交谈，不跟“陌生人”说话</p></blockquote><p>又称最少知道原则（Demeter Principle）</p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h2 id="七、合成复用原则-composite-reuse-principle" tabindex="-1"><a class="header-anchor" href="#七、合成复用原则-composite-reuse-principle"><span>七、合成复用原则（Composite Reuse Principle）</span></a></h2><blockquote><p>在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</p></blockquote>',22),p=[o];function r(c,s){return n(),i("div",null,p)}const u=e(t,[["render",r],["__file","principle.html.vue"]]),d=JSON.parse('{"path":"/soft-engineering/oo/principle.html","title":"编程原则","lang":"zh-CN","frontmatter":{"title":"编程原则","category":["面向对象"],"description":"一、开闭原则（Open Close Principle） 软件实体应当对扩展开放，对修改关闭 当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/soft-engineering/oo/principle.html"}],["meta",{"property":"og:site_name","content":"SE Docs"}],["meta",{"property":"og:title","content":"编程原则"}],["meta",{"property":"og:description","content":"一、开闭原则（Open Close Principle） 软件实体应当对扩展开放，对修改关闭 当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"lipengjgs"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编程原则\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"lipengjgs\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"一、开闭原则（Open Close Principle）","slug":"一、开闭原则-open-close-principle","link":"#一、开闭原则-open-close-principle","children":[]},{"level":2,"title":"二、里氏替换原则（Liskov Substitution Principle）","slug":"二、里氏替换原则-liskov-substitution-principle","link":"#二、里氏替换原则-liskov-substitution-principle","children":[]},{"level":2,"title":"三、依赖倒置原则（Dependence Inversion Principle）","slug":"三、依赖倒置原则-dependence-inversion-principle","link":"#三、依赖倒置原则-dependence-inversion-principle","children":[]},{"level":2,"title":"四、单一职责原则","slug":"四、单一职责原则","link":"#四、单一职责原则","children":[]},{"level":2,"title":"五、接口隔离原则（Interface Segregation Principle）","slug":"五、接口隔离原则-interface-segregation-principle","link":"#五、接口隔离原则-interface-segregation-principle","children":[]},{"level":2,"title":"六、迪米特法则","slug":"六、迪米特法则","link":"#六、迪米特法则","children":[]},{"level":2,"title":"七、合成复用原则（Composite Reuse Principle）","slug":"七、合成复用原则-composite-reuse-principle","link":"#七、合成复用原则-composite-reuse-principle","children":[]}],"git":{},"readingTime":{"minutes":3.21,"words":963},"filePathRelative":"soft-engineering/oo/principle.md","autoDesc":true,"excerpt":"<h2>一、开闭原则（Open Close Principle）</h2>\\n<blockquote>\\n<p>软件实体应当对扩展开放，对修改关闭</p>\\n</blockquote>\\n<blockquote>\\n<p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求\\n开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>\\n</blockquote>\\n<ol>\\n<li>项目中划分出的模块；</li>\\n<li>类与接口</li>\\n<li>方法</li>\\n</ol>"}');export{u as comp,d as data};
