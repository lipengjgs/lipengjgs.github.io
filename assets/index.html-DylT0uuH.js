import{_ as i,c as s,o as e,e as a}from"./app-DrONpEbx.js";const n={},l=a(`<h2 id="对比vue2-x-vue3-x变化在哪里" tabindex="-1"><a class="header-anchor" href="#对比vue2-x-vue3-x变化在哪里"><span>对比Vue2.x, Vue3.x变化在哪里</span></a></h2><h3 id="diff算法" tabindex="-1"><a class="header-anchor" href="#diff算法"><span>diff算法</span></a></h3><p>Vue 2 递归双指针遍历diff算法，它会遍历新旧两个虚拟节点树的每一层，进行逐个对比。</p><p>Vue 3 引入了 patch flag 的概念，并且对 diff 算法进行了优化，基于数组的动态规划的 diff 算法，比如在相同层级的元素间进行移动时，Vue 3 可以更高效地处理这种情况。</p><p>具体的优化点包括：</p><p>Vue 3 中会根据 patch flag 判断节点类型，如果是同类型节点则可以直接复用老节点的内容，只需对比新旧节点的 data 和 children 是否有变化。</p><p>Vue 3 中使用了 Fragments，可以让多个节点复用同一个 DOM 元素，无需额外标签。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 假设的 Vue 2 diff 算法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> diff</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">oldTree</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">newTree</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // 遍历比较整个虚拟 DOM 树</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 假设的 Vue 3 diff 算法</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> patch</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">oldNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">newNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> patchFlag</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> newNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">patchFlag</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">patchFlag</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> PATCH_FLAG_TYPE_TEXT</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 文本节点，直接更新内容</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    oldNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">textContent</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> newNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">text</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">patchFlag</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> PATCH_FLAG_FULL_PROPS</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 全新的属性，需要更新所有属性</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">patchFlag</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> ===</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> PATCH_FLAG_HYDRATE_EVENTS</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // 需要处理事件绑定</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Vue3通常会更高效，因为它减少了不必要的 DOM 操作，并且对特定类型的更改做了优化处理。</p><h3 id="架构部分" tabindex="-1"><a class="header-anchor" href="#架构部分"><span>架构部分</span></a></h3><p>TreeShaking TypeScript</p><h3 id="新增特性" tabindex="-1"><a class="header-anchor" href="#新增特性"><span>新增特性</span></a></h3><ul><li>framents</li></ul><blockquote><p>模板支持多个根节点</p></blockquote><ul><li>Teleport</li></ul><blockquote><p>将我们的模板移动到 DOM 中 Vue app 之外的其他位置</p></blockquote><ul><li><p>createRenderer</p></li><li><p>Composition API</p></li></ul><h3 id="不兼容的change" tabindex="-1"><a class="header-anchor" href="#不兼容的change"><span>不兼容的change</span></a></h3><ul><li><p>生命周期区别：</p><p>Vue2.x:beforeDestroy, destroyed Vue3.x: beforeUnmount, unmounted</p><p>1.Global API 全局 Vue API 已更改为使用应用程序实例 全局和内部 API 已经被重构为可 tree-shakable 2.模板指令 组件上 v-model 用法已更改 在同一元素上使用的 v-if 和 v-for 优先级已更改: 虽然Vue 3仍然允许在同一个元素上同时绑定v-for和v-if（‌尽管不推荐）‌，‌但执行顺序变为v-if优先于v-for v-bind=&quot;object&quot; 现在排序敏感 v-for 中的 ref 不再注册 ref 数组: 需要主动将 ref 绑定到一个更灵活的函数上 3.组件 只能使用普通函数创建功能组件 functional 属性在单文件组件 (SFC) 异步组件现在需要 defineAsyncComponent 方法来创建 4.渲染函数 渲染函数API改变 $scopedSlots property 已删除，所有插槽都通过 $slots 作为函数暴露 自定义指令 API 已更改为与组件生命周期一致 一些转换 class 被重命名了： 1.v-enter -&gt; v-enter-from 2.v-leave -&gt; v-leave-from 组件 watch 选项和实例方法 $watch 不再支持点分隔字符串路径，请改用计算函数作为参数 在 Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。Vue3.x 现在使用应用程序容器的 innerHTML。 5.其他小改变 destroyed 生命周期选项被重命名为 unmounted beforeDestroy 生命周期选项被重命名为 beforeUnmount prop default工厂函数不再有权访问 this 是上下文 自定义指令 API 已更改为与组件生命周期一致 data 应始终声明为函数 来自 mixin 的 data 选项现在可简单地合并 attribute 强制策略已更改 一些过渡 class 被重命名 组建 watch 选项和实例方法 $watch 不再支持以点分隔的字符串路径。请改用计算属性函数作为参数。 <code>&lt;template&gt;</code> 没有特殊指令的标记 (v-if/else-if/else、v-for 或 v-slot) 现在被视为普通元素，并将生成原生的 <code>&lt;template&gt;</code> 元素，而不是渲染其内部内容。 在Vue 2.x 中，应用根容器的 outerHTML 将替换为根组件模板 (如果根组件没有模板/渲染选项，则最终编译为模板)。Vue 3.x 现在使用应用容器的 innerHTML，这意味着容器本身不再被视为模板的一部分。 5.移除 API keyCode 支持作为 v-on 的修饰符 $on ， $off 和 $once 实例方法 过滤 filter 内联模板 attribute $destroy 实例方法。用户不应再手动管理单个Vue 组件的生命周期。</p></li></ul><h3 id="env" tabindex="-1"><a class="header-anchor" href="#env"><span>.env</span></a></h3><blockquote><p>.env.development和.env.production环境配置文件中变量名必须以VUE_APP_开头</p></blockquote><h3 id="深度选择器" tabindex="-1"><a class="header-anchor" href="#深度选择器"><span>深度选择器</span></a></h3><ol><li><p>/deep/</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> scoped</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.parent /deep/ .child </span><span style="--shiki-light:#24292E;--shiki-dark:#C678DD;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#C678DD;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>&gt;&gt;&gt;</code></p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#D19A66;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> scoped</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line highlighted"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> .parent /deep/ .child </span><span style="--shiki-light:#24292E;--shiki-dark:#C678DD;">{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#C678DD;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>::v-deep</p></li><li><p>v-deep()</p></li><li><p>:deep() {}</p></li></ol>`,23),t=[l];function h(p,k){return e(),s("div",null,t)}const r=i(n,[["render",h],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/soft-engineering/fe/fe-frames/vue/v3x/","title":"Vue3.x","lang":"zh-CN","frontmatter":{"title":"Vue3.x","footer":"","description":"对比Vue2.x, Vue3.x变化在哪里 diff算法 Vue 2 递归双指针遍历diff算法，它会遍历新旧两个虚拟节点树的每一层，进行逐个对比。 Vue 3 引入了 patch flag 的概念，并且对 diff 算法进行了优化，基于数组的动态规划的 diff 算法，比如在相同层级的元素间进行移动时，Vue 3 可以更高效地处理这种情况。 具体的优...","head":[["meta",{"property":"og:url","content":"https://lipengjgs.github.io/soft-engineering/fe/fe-frames/vue/v3x/"}],["meta",{"property":"og:site_name","content":"SE Docs"}],["meta",{"property":"og:title","content":"Vue3.x"}],["meta",{"property":"og:description","content":"对比Vue2.x, Vue3.x变化在哪里 diff算法 Vue 2 递归双指针遍历diff算法，它会遍历新旧两个虚拟节点树的每一层，进行逐个对比。 Vue 3 引入了 patch flag 的概念，并且对 diff 算法进行了优化，基于数组的动态规划的 diff 算法，比如在相同层级的元素间进行移动时，Vue 3 可以更高效地处理这种情况。 具体的优..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-31T13:46:57.000Z"}],["meta",{"property":"article:author","content":"lipengjgs"}],["meta",{"property":"article:modified_time","content":"2024-08-31T13:46:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue3.x\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-31T13:46:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"lipengjgs\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"对比Vue2.x, Vue3.x变化在哪里","slug":"对比vue2-x-vue3-x变化在哪里","link":"#对比vue2-x-vue3-x变化在哪里","children":[{"level":3,"title":"diff算法","slug":"diff算法","link":"#diff算法","children":[]},{"level":3,"title":"架构部分","slug":"架构部分","link":"#架构部分","children":[]},{"level":3,"title":"新增特性","slug":"新增特性","link":"#新增特性","children":[]},{"level":3,"title":"不兼容的change","slug":"不兼容的change","link":"#不兼容的change","children":[]},{"level":3,"title":".env","slug":"env","link":"#env","children":[]},{"level":3,"title":"深度选择器","slug":"深度选择器","link":"#深度选择器","children":[]}]}],"git":{"createdTime":1721029261000,"updatedTime":1725112017000,"contributors":[{"name":"jgs","email":"12345@qq.com","commits":2},{"name":"lipengjgs","email":"12345@qq.com","commits":1}]},"readingTime":{"minutes":3.73,"words":1119},"filePathRelative":"soft-engineering/fe/fe-frames/vue/v3x/README.md","localizedDate":"2024年7月15日","autoDesc":true,"excerpt":"<h2>对比Vue2.x, Vue3.x变化在哪里</h2>\\n<h3>diff算法</h3>\\n<p>Vue 2 递归双指针遍历diff算法，它会遍历新旧两个虚拟节点树的每一层，进行逐个对比。</p>\\n<p>Vue 3 引入了 patch flag 的概念，并且对 diff 算法进行了优化，基于数组的动态规划的 diff 算法，比如在相同层级的元素间进行移动时，Vue 3 可以更高效地处理这种情况。</p>\\n<p>具体的优化点包括：</p>\\n<p>Vue 3 中会根据 patch flag 判断节点类型，如果是同类型节点则可以直接复用老节点的内容，只需对比新旧节点的 data 和 children 是否有变化。</p>"}');export{r as comp,c as data};
