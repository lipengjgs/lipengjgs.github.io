import{_ as e,c as i,o as n,e as t}from"./app-ZrZUwRqL.js";const p={},l=t('<h2 id="一、开闭原则-open-close-principle" tabindex="-1"><a class="header-anchor" href="#一、开闭原则-open-close-principle"><span>一、开闭原则（Open Close Principle）</span></a></h2><blockquote><p>软件实体应当对扩展开放，对修改关闭</p><p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求</p><p>在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果；简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类</p></blockquote><ol><li>项目中划分出的模块</li><li>类与接口</li><li>方法</li></ol><p>&quot;抽象约束、封装变化&quot;：即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><h2 id="二、里氏替换原则-liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#二、里氏替换原则-liskov-substitution-principle"><span>二、里氏替换原则（Liskov Substitution Principle）</span></a></h2><blockquote><p>子类可以扩展父类的功能，但不能改变父类原有的功能</p><p>修正方法：程序违背了里氏替换原则，取消原来的继承关系，重新设计它们之间的关系 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p></blockquote><h2 id="三、依赖倒置原则-dependence-inversion-principle" tabindex="-1"><a class="header-anchor" href="#三、依赖倒置原则-dependence-inversion-principle"><span>三、依赖倒置原则（Dependence Inversion Principle）</span></a></h2><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 高层模块不应该依赖低层模块，两者都应该依赖其抽象 抽象不应该依赖细节，细节应该依赖抽象 面向接口编程</p><ol><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ol><h2 id="四、单一职责原则" tabindex="-1"><a class="header-anchor" href="#四、单一职责原则"><span>四、单一职责原则</span></a></h2><blockquote><p>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</p></blockquote><p>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度，它强调降低依赖，降低耦合</p><h2 id="五、接口隔离原则-interface-segregation-principle" tabindex="-1"><a class="header-anchor" href="#五、接口隔离原则-interface-segregation-principle"><span>五、接口隔离原则（Interface Segregation Principle）</span></a></h2><blockquote><p>尽量将臃肿庞大的接口拆分成更小的和更具体的接口</p></blockquote><h2 id="六、迪米特法则-demeter-principle" tabindex="-1"><a class="header-anchor" href="#六、迪米特法则-demeter-principle"><span>六、迪米特法则（Demeter Principle）</span></a></h2><blockquote><p>只与你的直接朋友交谈，不跟 &quot;陌生人&quot; 说话</p></blockquote><p>最少知道原则；一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h2 id="七、合成复用原则-composite-reuse-principle" tabindex="-1"><a class="header-anchor" href="#七、合成复用原则-composite-reuse-principle"><span>七、合成复用原则（Composite Reuse Principle）</span></a></h2><blockquote><p>在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</p></blockquote><h2 id="相关书籍" tabindex="-1"><a class="header-anchor" href="#相关书籍"><span>相关书籍</span></a></h2>',20),o=[l];function r(c,a){return n(),i("div",null,o)}const d=e(p,[["render",r],["__file","principle.html.vue"]]),h=JSON.parse('{"path":"/programming/oo/principle.html","title":"编程原则","lang":"zh-CN","frontmatter":{"title":"编程原则","category":["面向对象"],"footer":"","description":"一、开闭原则（Open Close Principle） 软件实体应当对扩展开放，对修改关闭 当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求 在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果；简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口...","head":[["meta",{"property":"og:url","content":"https://lipengjgs.github.io/programming/oo/principle.html"}],["meta",{"property":"og:site_name","content":"SE Docs"}],["meta",{"property":"og:title","content":"编程原则"}],["meta",{"property":"og:description","content":"一、开闭原则（Open Close Principle） 软件实体应当对扩展开放，对修改关闭 当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求 在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果；简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-18T08:16:44.000Z"}],["meta",{"property":"article:author","content":"lipengjgs"}],["meta",{"property":"article:modified_time","content":"2024-07-18T08:16:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"编程原则\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-07-18T08:16:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"lipengjgs\\",\\"url\\":\\"\\"}]}"]]},"headers":[{"level":2,"title":"一、开闭原则（Open Close Principle）","slug":"一、开闭原则-open-close-principle","link":"#一、开闭原则-open-close-principle","children":[]},{"level":2,"title":"二、里氏替换原则（Liskov Substitution Principle）","slug":"二、里氏替换原则-liskov-substitution-principle","link":"#二、里氏替换原则-liskov-substitution-principle","children":[]},{"level":2,"title":"三、依赖倒置原则（Dependence Inversion Principle）","slug":"三、依赖倒置原则-dependence-inversion-principle","link":"#三、依赖倒置原则-dependence-inversion-principle","children":[]},{"level":2,"title":"四、单一职责原则","slug":"四、单一职责原则","link":"#四、单一职责原则","children":[]},{"level":2,"title":"五、接口隔离原则（Interface Segregation Principle）","slug":"五、接口隔离原则-interface-segregation-principle","link":"#五、接口隔离原则-interface-segregation-principle","children":[]},{"level":2,"title":"六、迪米特法则（Demeter Principle）","slug":"六、迪米特法则-demeter-principle","link":"#六、迪米特法则-demeter-principle","children":[]},{"level":2,"title":"七、合成复用原则（Composite Reuse Principle）","slug":"七、合成复用原则-composite-reuse-principle","link":"#七、合成复用原则-composite-reuse-principle","children":[]},{"level":2,"title":"相关书籍","slug":"相关书籍","link":"#相关书籍","children":[]}],"git":{"createdTime":1719488606000,"updatedTime":1721290604000,"contributors":[{"name":"jgs","email":"12345@qq.com","commits":2}]},"readingTime":{"minutes":2.94,"words":882},"filePathRelative":"programming/oo/principle.md","localizedDate":"2024年6月27日","autoDesc":true,"excerpt":"<h2>一、开闭原则（Open Close Principle）</h2>\\n<blockquote>\\n<p>软件实体应当对扩展开放，对修改关闭</p>\\n<p>当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求</p>\\n<p>在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果；简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类</p>\\n</blockquote>\\n<ol>\\n<li>项目中划分出的模块</li>\\n<li>类与接口</li>\\n<li>方法</li>\\n</ol>\\n<p>\\"抽象约束、封装变化\\"：即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p>"}');export{d as comp,h as data};
